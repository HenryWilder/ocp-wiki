---
import { CollectionEntry, getCollection } from 'astro:content';
import Document from '../../layouts/Document.astro';

// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
  const objectEntries = await getCollection('objects');
  return objectEntries.map(entry => ({
    params: { name: entry.slug }, props: { entry },
  }));
}

// 2. When it's time to render, you can get the entry directly from the prop
const { entry } = Astro.props;
const { Content } = await entry.render();

// Find next and previous entry in the collection
// Only includes entries whose slug does not end with "vX"
const objectEntries = await getCollection('objects', (e) => e.slug.match(/v\d+$/) == null);
const currentIndex = objectEntries.findIndex((e: { slug: any; }) => e.slug == entry.slug);
const prevEntry: CollectionEntry<'objects'> = objectEntries[currentIndex - 1] ?? objectEntries.find((e) => e.data.name == 'err');
const nextEntry = objectEntries[currentIndex + 1] ?? objectEntries.find((e) => e.data.name == 'err');

// Get list of all entries with the same name as the current entry
// Sort ascending by version number
const objectVersions = await getCollection('objects', e => e.data.name == entry.data.name);
const sortedVersions = objectVersions.sort((a, b) => a.data.version - b.data.version);
const latestVersionSlug = sortedVersions[sortedVersions.length - 1].slug;
const isOldVersion = entry.slug != latestVersionSlug;

import { remark } from 'remark';
import remarkMdx from 'remark-mdx';

const ast = remark().use(remarkMdx).parse(entry.body);
const headings = ast.children
  .map(node => (node.type == 'heading' && node.children[0].type == 'text') ?
    { depth:node.depth, name:node.children[0].value, link:'#'+node.children[0].value.replaceAll(' ', '-').toLowerCase() } : null)
  .filter(result => result !== null);
---
<Document title={entry.data.title} desc={entry.data.desc} addKeywords={entry.data.tags} >
  <main>
    <aside id="outline">
      <h2>{entry.data.title}</h2>
      <ol>
        {headings.map(heading => <li><a href={heading.link}><Fragment set:html={'&nbsp;'.repeat((heading.depth - 1) * 2)}/>{heading.name}</a></li>)}
      </ol>
    </aside>

    <article>
      <div id="hrgroup">
        <h1>{entry.data.title}</h1>

        {isOldVersion &&
            <b style="font-size:smaller">NOTICE: You are reading an outdated version of this document</b>
        }

        <span id="file-history">
          {sortedVersions.length > 1 && sortedVersions.map(v => <a href={v.slug!=entry.slug ? v.slug : ''}>V{v.data.version}{v.slug == latestVersionSlug ? ' (latest)' : ''}</a>)}
        </span>
      </div>
      <p><b>{entry.data.name}:</b> {entry.data.title} ({entry.data.category})</p>

      <Content/>
      {entry.data.reports?.map(e => e.render())}

      <footer style="text-align: center;margin-block:2em">&laquo; <a href={prevEntry.slug}>Prev</a> &bull; <a href={nextEntry.slug}>Next</a> &raquo;</footer>
    </article>

    <aside id="comments">
      {entry.data.comments}
    </aside>
  </main>
  <script>
    // Move comments to the 'comments' aside
    // Make sure comments are at the same offset height as they appear in the markdown
    const main = document.querySelector('main');
    const mainTop = main.offsetTop;
    const commentSection = document.getElementById('comments');
    const comments = document.querySelectorAll('.comment');
    let mustClear = mainTop;
    comments.forEach((comment: HTMLElement, i: number) => {
      comment.style.position = 'absolute';
      // Get the offset height of the object
      const offset = comment.offsetTop - mainTop - comment.offsetHeight / 2;
      commentSection.appendChild(comment)
      comment.style.top = offset+'px';
      // Move down if overlapping the previous comment
      if (i > 0) {
        const prevComment = comments[i-1] as HTMLElement;
        if (mustClear < prevComment.offsetTop) mustClear = prevComment.offsetTop;
        mustClear += prevComment.offsetHeight + 10;
        if (comment.offsetTop < mustClear) {
          comment.style.top = mustClear+'px';
        }
      }
    });
  </script>
</Document>
