---
import Document from "../layouts/Document.astro";
const origin = Astro.url.origin;
---
<Document title="Search" desc="[Under construction]">
    <article>
        <p><strong>Showing results for: </strong><span id="query-text"><noscript>n/a</noscript></span></p>
        <div class="comment-name">Found <span id="result-count"><noscript>no</noscript></span> results in <span id="result-time"><noscript>n/a seconds</noscript></span>.</div>
        <!-- Measured from the time collections are fetched to the moment results are found and ready to render -->

        <ul class="card-list" id="search-results">
            <noscript>Search cannot work if script is disabled.</noscript>
        </ul>
    </article>

    <script>
        import type { CollectionEntry } from 'astro:content';
        import { getCollection } from 'astro:content';
    
        const objectCollection:    CollectionEntry<'objects'>[]             = await getCollection('objects', (o) => o.data.visibility != 'hidden');
        const authorCollection:    CollectionEntry<'authors'>[]             = await getCollection('authors');
        const classCollection:     CollectionEntry<'containment-classes'>[] = await getCollection('containment-classes');
        const siteCollection:      CollectionEntry<'containment-sites'>[]   = await getCollection('containment-sites');
        const taskForceCollection: CollectionEntry<'task-forces'>[]         = await getCollection('task-forces');
        const reportCollection:    CollectionEntry<'reports'>[]             = await getCollection('reports');
    
        export interface Searchable {
            name: string;
            path: string;
            description: string;
            iconPath?: string;
            keywords: string[];
            multiplier: number;
        }
    
        let searchDataRaw: Searchable[] = [];

        const iconFromCategory = (category: string): string|undefined => {
            switch (category) {
                case 'Apollyon': return '/thumbnail-apollyon.png';
                case 'Catastrophic': return '/thumbnail-catastrophic.png';
                case 'Yaaqov': return '/thumbnail-yaaqov.png';
                case 'Esau': return '/thumbnail-esau.png';
                default: return undefined;
            }
        }
    
        // Object results
        searchDataRaw = searchDataRaw
            .concat(objectCollection
                .map((e) => { return {
                    name: `OCP-${e.data.name}: ${e.data.title} (${e.data.category}) [V${e.data.version}]`,
                    path: `/objects/${e.slug}/`,
                    description: e.data.description,
                    iconPath: iconFromCategory(e.data.category),
                    keywords: [...e.data.tags, e.data.description, e.data.title, 'objects', 'ocp', `ocp-${e.data.name}`, e.data.name, e.data.category, e.data.author],
                    multiplier: 1 };
                })
            );
    
        // Author results
        searchDataRaw = searchDataRaw
            .concat(authorCollection
                .map((e) => { return {
                    name: e.data.name,
                    path: `/about/authors/${e.slug}/`,
                    description: e.data.description,
                    iconPath: e.data.icon,
                    keywords: ['authors',e.data.name, e.data.description],
                    multiplier: 3 };
                })
            );
    
        // Class results
        searchDataRaw = searchDataRaw
            .concat(classCollection
                .map((e) => { return {
                    name: e.data.name,
                    path: `/info/containment-classes/${e.slug}/`,
                    description: e.data.blurb,
                    iconPath: iconFromCategory(e.data.name),
                    keywords: [e.data.name, e.data.blurb],
                    multiplier: 3 };
                })
            );
    
        // Site results
        searchDataRaw = searchDataRaw
            .concat(siteCollection
                .map((e) => { return {
                    name: e.data.name,
                    path: `/info/containment-sites/${e.slug}/`,
                    description: e.data.blurb,
                    keywords: ['site', e.data.name, e.data.blurb],
                    multiplier: 3 };
                })
            );
    
        // Task force results
        searchDataRaw = searchDataRaw
            .concat(taskForceCollection
                .map((e) => { return {
                    name: `MTF-${e.data.name}`,
                    path: `/info/task-forces/${e.slug}/`,
                    description: e.data.blurb,
                    keywords: ['task force', 'mtf', e.data.name, e.data.blurb],
                    multiplier: 3 };
                })
            );
    
        // Report results
        searchDataRaw = searchDataRaw
            .concat(reportCollection
                .map((e) => { return {
                    name: `${e.data.type} ${e.data.object} ${e.data.instance}`,
                    path: `/info/task-forces/${e.slug}/`,
                    description: `${e.data.type} #${e.data.instance} for OCP-${e.data.object} `,
                    keywords: ['report', `${e.data.type} ${e.data.object} ${e.data.instance}`],
                    multiplier: 1 };
                })
            );
            
        const searchData: Searchable[] = searchDataRaw;
    
        const queryInit: string[] = location.search.substring(location.search.indexOf("=")+1).toLowerCase().split('+').map((e) => e.replaceAll('%22','"'));
        const exactMatch: boolean = queryInit.includes('"');
        const isDebug: boolean = queryInit[0] === 'debug';
        const query: string[] = exactMatch ? [] : queryInit.filter(e => e !== 'debug');
        const queryLiteral: string = query.join(' ').replaceAll('"',''); // Higher priority than individual words
        document.querySelector("#query-text")!.outerHTML = `${query.join(' ')}`;
    
        interface Result {
            name: string;
            path: string;
            description: string;
            iconPath?: string;
            relevance: number;
            multiplier: number; // For debugging
        }
    
        const countReferences = (src: string[]): number =>
            exactMatch
                ?   src .map(keyword => keyword.toLowerCase())
                        .filter((kw: string) => kw.includes(queryLiteral))
                        .length
    
                :   src .map(keyword => keyword.toLowerCase())
                        .filter((kw: string) => kw.includes(queryLiteral))
                        .length * 3
                    +
                    query.map((q) =>
                            src .map(keyword => keyword.toLowerCase())
                                .filter((kw: string) => kw.includes(q))
                                .length)
                        .reduce((p, c) => p + c, 0);
    
        const timeStart: number = performance.now();
    
        const results: Result[] = searchData.map(
            (e) => {
                const relevance: number = countReferences(e.keywords) * e.multiplier;
                return {
                    name: e.name,
                    path: e.path,
                    description: e.description,
                    iconPath: e.iconPath,
                    relevance: relevance,
                    multiplier: e.multiplier
                };
            })
            .filter((e) => e.relevance > 0)
            .sort((a, b) => a.name.localeCompare(b.name))
            .sort((a, b) => b.relevance - a.relevance);
    
        const timeFinish: number = performance.now();
    
        // Render results
        document.querySelector('#search-results').innerHTML = results.map((r) =>
            `<li ${r.iconPath ? `class="has-icon" style="background-image:url(${r.iconPath})"` : ''}>
                ${r.iconPath !== undefined ? `<img src="${r.iconPath}"/>` : ''}
                <div class="result-text">
                    <a href="${r.path}">${r.name}</a>
                    <span>${r.path.split('/').filter(e => e.length > 0).join(' > ')}</span>
                    <span>${r.description}</span>
                    ${isDebug ? `<span><b>${r.relevance / r.multiplier}</b><sub>(matches)</sub> &bull; <b>${r.multiplier}</b><sub>(multiplier)</sub> = <b>${r.relevance}</b><sub>(relevance)</sub></span>` : ''}
                </div>
            </li>`
        ).join('\n');
    
        const searchTime: number = timeFinish - timeStart;
        const timeSlot = document.querySelector("#result-time");
        if (searchTime < 1000)
            timeSlot!.outerHTML = searchTime.toFixed(2) + " milliseconds";
        else
            timeSlot!.outerHTML = (searchTime / 1000).toFixed(2) + " seconds";
        document.querySelector("#result-count")!.outerHTML = results.length.toString();
    
        const searchbar = document.querySelector('#searchbar') as HTMLInputElement;
        searchbar.value = queryInit.join(' ');
        searchbar.focus();
    </script>
</Document>
